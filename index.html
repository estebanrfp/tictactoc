<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tic Tac Toe | Minimalist Premium Edition</title>
    <meta name="description" content="A stunningly minimalist Tic Tac Toe game with premium glassmorphic design and smooth animations.">
    
    <!-- Google Fonts: Inter & Outfit -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Outfit:wght@500;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-color: #050505;
            --card-bg: rgba(255, 255, 255, 0.03);
            --border-color: rgba(255, 255, 255, 0.1);
            --text-primary: #ffffff;
            --text-secondary: #a0a0a0;
            --accent-x: #00f2ff; /* Neon Blue */
            --accent-o: #ff2d55; /* Ruby Red */
            --glass-blur: 15px;
            --transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-font-smoothing: antialiased;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(0, 242, 255, 0.05) 0%, transparent 40%),
                radial-gradient(circle at 90% 80%, rgba(255, 45, 85, 0.05) 0%, transparent 40%);
            color: var(--text-primary);
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2rem;
            animation: fadeIn 1s ease-out;
            max-width: 400px;
            width: 90%;
        }

        #lobby {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            align-items: center;
            background: var(--card-bg);
            padding: 2.5rem;
            border-radius: 32px;
            backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--border-color);
            text-align: center;
        }

        input {
            background: rgba(255,255,255,0.05);
            border: 1px solid var(--border-color);
            padding: 12px 20px;
            border-radius: 12px;
            color: white;
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            outline: none;
            width: 100%;
            text-align: center;
            transition: var(--transition);
        }

        input:focus {
            border-color: var(--accent-x);
            background: rgba(255,255,255,0.08);
        }

        header {
            text-align: center;
        }

        h1 {
            font-family: 'Outfit', sans-serif;
            font-weight: 700;
            font-size: 2.5rem;
            letter-spacing: -0.02em;
            margin-bottom: 0.5rem;
            background: linear-gradient(to right, #fff, rgba(255,255,255,0.5));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .status {
            font-weight: 300;
            color: var(--text-secondary);
            font-size: 1rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }

        .player-info {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
            opacity: 0.8;
        }

        /* Board Styling */
        .board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            padding: 12px;
            background: var(--card-bg);
            backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--border-color);
            border-radius: 24px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }

        .cell {
            width: 100px;
            height: 100px;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            font-family: 'Outfit', sans-serif;
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }

        .cell:hover:not(.x):not(.o) {
            background: rgba(255, 255, 255, 0.05);
            transform: scale(1.02);
        }

        .cell.x { color: var(--accent-x); text-shadow: 0 0 20px rgba(0, 242, 255, 0.5); }
        .cell.o { color: var(--accent-o); text-shadow: 0 0 20px rgba(255, 45, 85, 0.5); }

        .cell.win {
            background: rgba(0, 242, 255, 0.1);
            border-color: var(--accent-x);
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 1rem;
        }

        button {
            background: #ffffff;
            color: #000;
            border: none;
            padding: 12px 32px;
            border-radius: 12px;
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: var(--transition);
            box-shadow: 0 4px 12px rgba(255, 255, 255, 0.1);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(255, 255, 255, 0.2);
            filter: brightness(0.9);
        }

        button:active {
            transform: translateY(0);
        }

        /* Modal / Winner Screen */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .overlay.show {
            display: flex;
            opacity: 1;
        }

        .winner-text {
            font-family: 'Outfit', sans-serif;
            font-size: 4rem;
            font-weight: 700;
            margin-bottom: 2rem;
            text-align: center;
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .cell span {
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes popIn {
            from { opacity: 0; transform: scale(0.5); }
            to { opacity: 1; transform: scale(1); }
        }

        /* Responsive */
        @media (max-width: 480px) {
            .cell { width: 80px; height: 80px; font-size: 2rem; }
            h1 { font-size: 2rem; }
        }

        /* Player Role Badges */
        .player-badge {
            display: inline-block;
            padding: 0.4rem 1rem;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9rem;
            margin-top: 0.5rem;
        }
        .player-badge.x {
            background: rgba(255, 45, 85, 0.2);
            color: var(--x-color);
            border: 1px solid var(--x-color);
        }
        .player-badge.o {
            background: rgba(50, 215, 251, 0.2);
            color: var(--o-color);
            border: 1px solid var(--o-color);
        }
        .player-badge.spectator {
            background: rgba(255, 200, 50, 0.2);
            color: #ffc832;
            border: 1px solid #ffc832;
        }
        .spectator-count {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.5);
            margin-top: 0.3rem;
        }
    </style>
</head>
<body>

    <div class="container" id="lobby-container">
        <header>
            <h1>Join a Room</h1>
            <div class="status">Enter a room ID to start playing</div>
        </header>

        <div id="lobby">
            <input type="text" id="room-input" placeholder="e.g. secret-battle" maxlength="20">
            <button id="join-btn">Join Match</button>
            <div id="protocol-warning" style="display: none; color: #ff2d55; font-size: 0.8rem; margin-top: 1rem; line-height: 1.4;">
                ‚ö†Ô∏è <strong>Security Restriction:</strong> GenosDB requires a local server. <br> Run <code>bun x serve ./</code> to play!
            </div>
        </div>
    </div>

    <div class="container" id="game-container" style="display: none;">
        <header>
            <h1>Tic Tac Toe</h1>
            <div id="status" class="status">Waiting for Opponent...</div>
            <div id="player-status" class="player-info"></div>
            <div id="spectator-count" class="spectator-count"></div>
        </header>

        <main class="board" id="board">
            <div class="cell" data-index="0" id="cell-0"></div>
            <div class="cell" data-index="1" id="cell-1"></div>
            <div class="cell" data-index="2" id="cell-2"></div>
            <div class="cell" data-index="3" id="cell-3"></div>
            <div class="cell" data-index="4" id="cell-4"></div>
            <div class="cell" data-index="5" id="cell-5"></div>
            <div class="cell" data-index="6" id="cell-6"></div>
            <div class="cell" data-index="7" id="cell-7"></div>
            <div class="cell" data-index="8" id="cell-8"></div>
        </main>

        <footer class="controls">
            <button id="reset-btn">Reset Match</button>
            <button id="share-btn" style="background: rgba(255,255,255,0.1); color: white; border: 1px solid var(--border-color);">Copy Link</button>
        </footer>
    </div>

    <div class="overlay" id="overlay">
        <div class="winner-text" id="winner-text">X Wins!</div>
        <button id="play-again-btn">Play Again</button>
    </div>

    <script type="module">
        import { gdb } from "https://cdn.jsdelivr.net/npm/genosdb@latest/dist/index.min.js";

        /**
         * Multiplayer Tic Tac Toe - GenosDB Real-time Logic
         * Using top-level await as per GenosDB best practices
         */

        // Check protocol first
        if (window.location.protocol === 'file:') {
            document.getElementById('protocol-warning').style.display = 'block';
        }

        // === 1. Initialize GenosDB with top-level await ===
        const db = await gdb("ttt-premium", { rtc: true });
        const room = db.room;
        const gameChannel = room.channel("game-state");

        console.log("‚úÖ GenosDB and RTC initialized at top level");

        const state = {
            roomId: null,
            mySymbol: null,
            connectedPeers: new Set(),
            local: {
                board: Array(9).fill(null),
                currentPlayer: 'X',
                isGameActive: true,
                players: {}
            }
        };

        const winningCombinations = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8],
            [0, 3, 6], [1, 4, 7], [2, 5, 8],
            [0, 4, 8], [2, 4, 6]
        ];

        // UI Elements
        const lobbyContainer = document.getElementById('lobby-container');
        const gameContainer = document.getElementById('game-container');
        const roomInput = document.getElementById('room-input');
        const joinBtn = document.getElementById('join-btn');
        const boardEl = document.getElementById('board');
        const cells = document.querySelectorAll('.cell');
        const statusEl = document.getElementById('status');
        const playerStatusEl = document.getElementById('player-status');
        const overlayEl = document.getElementById('overlay');
        const winnerTextEl = document.getElementById('winner-text');
        const resetBtn = document.getElementById('reset-btn');
        const playAgainBtn = document.getElementById('play-again-btn');
        const shareBtn = document.getElementById('share-btn');
        const spectatorCountEl = document.getElementById('spectator-count');

        // === 2. Set up RTC listeners immediately (at top level) ===
        
        // Listen for real-time state updates from peers
        gameChannel.on("message", (msg, peerId) => {
            console.log(`üì® Message from ${peerId}:`, msg);
            console.log(`üìç My roomId: ${state.roomId}, msg.roomId: ${msg.roomId}`);
            
            // Skip if we're in a different room (but allow if roomId not set yet)
            if (state.roomId && msg.roomId && msg.roomId !== state.roomId) {
                console.log("‚è≠Ô∏è Skipping message for different room");
                return;
            }
            
            if (msg.type === 'state' && msg.payload) {
                console.log("üéÆ Applying state:", msg.payload);
                console.log("üìä Current board:", msg.payload.board);
                state.local = { ...msg.payload };
                
                // Re-sync assignment if we don't have a symbol yet, or if players changed
                const players = msg.payload.players || {};
                const needsAssignment = !state.mySymbol || 
                    (players.X && players.O && state.mySymbol !== 'X' && state.mySymbol !== 'O' && state.mySymbol !== 'Spectator');
                
                if (needsAssignment && state.roomId) {
                    console.log("üîÑ Re-syncing player assignment...");
                    syncPlayerAssignment();
                }
                
                // Always update UI when receiving state
                updateUI();

            } else if (msg.type === 'sync-request') {
                // Only respond to sync requests for our room
                if (!msg.roomId || msg.roomId === state.roomId) {
                    console.log(`üîÑ Sync request from ${peerId}, sending state...`);
                    if (state.local.board && state.roomId) {
                        gameChannel.send({ type: 'state', roomId: state.roomId, payload: state.local });
                    }
                }
            }
        });

        room.on("peer:join", (peerId) => {
            console.log(`‚ö° Peer joined: ${peerId}`);
            state.connectedPeers.add(peerId);
            updatePeerCount();
            
            // Send current state to new peer
            if (state.roomId && state.local.board) {
                setTimeout(() => {
                    console.log(`üì§ Sending state to new peer ${peerId}`);
                    gameChannel.send({ type: 'state', roomId: state.roomId, payload: state.local });
                }, 100);
            }
        });

        room.on("peer:leave", (peerId) => {
            console.log(`üëã Peer left: ${peerId}`);
            state.connectedPeers.delete(peerId);
            updatePeerCount();
        });

        const updatePeerCount = () => {
            const totalPeers = state.connectedPeers.size;
            // 2 players + spectators
            const spectators = Math.max(0, totalPeers - 1); // -1 because we count ourselves
            if (spectators > 0) {
                spectatorCountEl.textContent = `üëÅÔ∏è ${spectators} spectator${spectators > 1 ? 's' : ''} watching`;
            } else {
                spectatorCountEl.textContent = '';
            }
        };

        // === 3. Helper Functions ===
        
        async function saveState(newState) {
            state.local = newState;
            await db.put(newState, state.roomId);
            gameChannel.send({ type: 'state', roomId: state.roomId, payload: newState });
        }

        function resetGame() {
            if (state.mySymbol === 'Spectator') return;
            const newState = {
                board: Array(9).fill(null),
                currentPlayer: 'X',
                isGameActive: true,
                players: state.local.players || {}
            };
            saveState(newState);
            updateUI();
        }

        const syncPlayerAssignment = () => {
            const players = state.local.players || {};
            // Use sessionStorage so each tab/window gets a unique ID
            const me = sessionStorage.getItem('ttt_user_id') || Math.random().toString(36).substring(7);
            sessionStorage.setItem('ttt_user_id', me);

            let needsUpdate = false;

            if (!players.X) {
                players.X = me;
                state.mySymbol = 'X';
                needsUpdate = true;
                console.log("üë§ Assigned as X (creator)");
            } else if (players.X === me) {
                state.mySymbol = 'X';
                console.log("üë§ Recognized as X");
            } else if (!players.O) {
                players.O = me;
                state.mySymbol = 'O';
                needsUpdate = true;
                console.log("üë§ Assigned as O (joiner)");
            } else if (players.O === me) {
                state.mySymbol = 'O';
                console.log("üë§ Recognized as O");
            } else {
                state.mySymbol = 'Spectator';
                console.log("üëÅÔ∏è Assigned as Spectator");
                // Disable reset button immediately for spectators
                resetBtn.disabled = true;
                resetBtn.style.opacity = '0.3';
                resetBtn.style.cursor = 'not-allowed';
            }

            if (needsUpdate) {
                saveState({ ...state.local, players });
            }

            // Update UI will handle the badge display
            updateUI();
        };

        const checkWinner = (board) => {
            if (!board || !Array.isArray(board)) return null;
            for (const combo of winningCombinations) {
                const [a, b, c] = combo;
                if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                    return { winner: board[a], combo };
                }
            }
            return board.every(cell => cell !== null) ? { winner: 'Draw' } : null;
        };

        const updateUI = () => {
            const { board, currentPlayer } = state.local;
            if (!board) return;
            
            console.log("üñºÔ∏è Rendering board:", board);

            cells.forEach((cell, i) => {
                const val = board[i];
                cell.textContent = '';
                cell.classList.remove('x', 'o', 'win');
                if (val) {
                    const span = document.createElement('span');
                    span.textContent = val;
                    cell.appendChild(span);
                    cell.classList.add(val.toLowerCase());
                }
            });

            const players = state.local.players || {};
            const bothPlayersConnected = players.X && players.O;
            const result = checkWinner(board);
            
            if (result) {
                if (result.winner === 'Draw') {
                    statusEl.textContent = "It's a Draw!";
                    showEndScreen("It's a Draw!");
                } else {
                    statusEl.textContent = `${result.winner} Wins!`;
                    highlightWinningLine(result.combo);
                    setTimeout(() => showEndScreen(`${result.winner} Wins!`), 600);
                }
                boardEl.style.pointerEvents = "none";
                boardEl.style.opacity = "0.7";
            } else if (!bothPlayersConnected) {
                statusEl.textContent = "Waiting for opponent...";
                boardEl.style.opacity = "0.5";
                boardEl.style.pointerEvents = "none";
            } else {
                const isMyTurn = state.mySymbol === currentPlayer;
                const isSpectator = state.mySymbol === 'Spectator';
                
                if (isSpectator) {
                    statusEl.textContent = `${currentPlayer}'s Turn`;
                    boardEl.style.opacity = "1";
                    boardEl.style.pointerEvents = "none";
                } else {
                    statusEl.textContent = isMyTurn ? "Your Turn" : `Waiting for ${currentPlayer}...`;
                    boardEl.style.opacity = isMyTurn ? "1" : "0.7";
                    boardEl.style.pointerEvents = isMyTurn ? "auto" : "none";
                }
                overlayEl.classList.remove('show');
            }

            // Player status with badge
            const badgeClass = state.mySymbol?.toLowerCase() || '';
            if (state.mySymbol === 'Spectator') {
                playerStatusEl.innerHTML = `<span class="player-badge spectator">üëÅÔ∏è Spectator Mode</span>`;
                resetBtn.disabled = true;
                resetBtn.style.opacity = '0.3';
                resetBtn.style.cursor = 'not-allowed';
            } else if (state.mySymbol) {
                playerStatusEl.innerHTML = `<span class="player-badge ${badgeClass}">Playing as ${state.mySymbol}</span>`;
                resetBtn.disabled = false;
                resetBtn.style.opacity = '1';
                resetBtn.style.cursor = 'pointer';
            } else {
                playerStatusEl.textContent = 'Connecting...';
            }
        };

        const handleCellClick = (e) => {
            const cell = e.target.closest('.cell');
            if (!cell || state.mySymbol === 'Spectator') return;
            
            const index = parseInt(cell.dataset.index);
            const { board, currentPlayer, isGameActive, players } = state.local;

            const bothPlayersConnected = players?.X && players?.O;
            if (!bothPlayersConnected) return;

            if (!board || board[index] || !isGameActive) return;
            if (state.mySymbol !== currentPlayer) return;

            const newBoard = [...board];
            newBoard[index] = state.mySymbol;
            
            const result = checkWinner(newBoard);
            const nextPlayer = currentPlayer === 'X' ? 'O' : 'X';
            
            const newState = {
                ...state.local,
                board: newBoard,
                currentPlayer: nextPlayer,
                isGameActive: !result
            };
            state.local = newState;
            updateUI();
            saveState(newState);
        };

        const highlightWinningLine = (combo) => {
            cells.forEach(c => c.classList.remove('win'));
            combo.forEach(index => {
                document.getElementById(`cell-${index}`).classList.add('win');
            });
        };

        const showEndScreen = (text) => {
            winnerTextEl.textContent = text;
            overlayEl.classList.add('show');
        };

        const shareGame = () => {
            const url = new URL(window.location.href);
            url.searchParams.set('room', state.roomId);
            navigator.clipboard.writeText(url.href).then(() => {
                const originalText = shareBtn.textContent;
                shareBtn.textContent = 'Copied!';
                setTimeout(() => shareBtn.textContent = originalText, 2000);
            });
        };

        // === 4. Join Room Function (only room-specific logic) ===
        const joinRoom = async (roomId) => {
            state.roomId = roomId;
            
            // Show game UI
            lobbyContainer.style.display = 'none';
            gameContainer.style.display = 'flex';

            // Load initial state from database
            const { result: node } = await db.get(roomId);
            console.log("üì° Initial node from DB:", node);
            
            const data = node?.value;
            
            if (data && typeof data === 'object' && data.board) {
                console.log("üéÆ Loaded existing game:", data);
                state.local = { ...data };
                
                const hasPlayers = data.players && (data.players.X || data.players.O);
                if (!data.isGameActive && !state.mySymbol && !hasPlayers) {
                    resetGame();
                    return;
                }

                syncPlayerAssignment();
                updateUI();
            } else {
                console.log("üÜï Creating new room:", roomId);
                const initialState = {
                    board: Array(9).fill(null),
                    currentPlayer: 'X',
                    isGameActive: true,
                    players: {}
                };
                state.local = initialState;
                await db.put(initialState, roomId);
                syncPlayerAssignment();
                updateUI();
            }

            // Request sync from existing peers (with retries for slow cross-browser connections)
            let syncRetries = 0;
            const maxRetries = 5;
            
            const requestSync = () => {
                syncRetries++;
                console.log(`üîÑ Requesting sync from peers (attempt ${syncRetries}/${maxRetries})...`);
                gameChannel.send({ type: 'sync-request', roomId: state.roomId });
                
                // Retry if we still don't have proper player assignment
                if (syncRetries < maxRetries) {
                    setTimeout(() => {
                        // Only retry if we still need to sync (no symbol or waiting for opponent)
                        const players = state.local.players || {};
                        const bothPlayers = players.X && players.O;
                        if (!bothPlayers || !state.mySymbol) {
                            requestSync();
                        }
                    }, 1000);
                }
            };
            
            setTimeout(requestSync, 300);
        };

        // === 5. Event Listeners ===
        joinBtn.addEventListener('click', () => {
            const id = roomInput.value.trim();
            if (!id) {
                roomInput.style.border = '2px solid #ff2d55';
                roomInput.placeholder = 'Please enter a room name!';
                roomInput.focus();
                setTimeout(() => {
                    roomInput.style.border = '';
                    roomInput.placeholder = 'Enter room name';
                }, 2000);
                return;
            }
            joinRoom(id);
        });

        roomInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') joinBtn.click();
        });

        boardEl.addEventListener('click', handleCellClick);
        resetBtn.addEventListener('click', resetGame);
        playAgainBtn.addEventListener('click', resetGame);
        shareBtn.addEventListener('click', shareGame);

        // Auto-join if room in URL
        const params = new URLSearchParams(window.location.search);
        if (params.has('room')) {
            roomInput.value = params.get('room');
            joinRoom(params.get('room'));
        }
    </script>
</body>
</html>
